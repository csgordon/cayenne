module System$Int = 
concrete struct
abstract native Int :: # = "SUM"
native (+) :: Int -> Int -> Int = "\\x -> \\y -> x + y :: Int"
native (-) :: Int -> Int -> Int = "\\x -> \\y -> x - y :: Int"
native (*) :: Int -> Int -> Int = "\\x -> \\y -> x * y :: Int"
native quot:: Int -> Int -> Int = "\\x -> \\y -> x `quot` y :: Int"
native rem :: Int -> Int -> Int = "\\x -> \\y -> x `rem` y :: Int"
native negate :: Int -> Int = "\\x -> -x :: Int"
native odd :: Int -> System$Bool.Bool = "\\x -> (x :: Int) `rem` 2 == 1"
native even :: Int -> System$Bool.Bool = "\\x -> (x :: Int) `rem` 2 == 0"
native (==) :: Int -> Int -> System$Bool.Bool = "\\x -> \\y -> x == (y :: Int)"
native (/=) :: Int -> Int -> System$Bool.Bool = "\\x -> \\y -> x /= (y :: Int)"
native (<=) :: Int -> Int -> System$Bool.Bool = "\\x -> \\y -> x <= (y :: Int)"
native (>=) :: Int -> Int -> System$Bool.Bool = "\\x -> \\y -> x >= (y :: Int)"
native (<) :: Int -> Int -> System$Bool.Bool = "\\x -> \\y -> x < (y :: Int)"
native (>) :: Int -> Int -> System$Bool.Bool = "\\x -> \\y -> x > (y :: Int)"
abstract native show :: Int -> System$String.String = "\\x -> show (x::Int)"
abstract native read :: System$String.String -> Int = "\\x -> (read x) :: Int"
